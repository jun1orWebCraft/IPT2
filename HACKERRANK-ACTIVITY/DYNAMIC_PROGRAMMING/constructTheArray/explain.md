Weâ€™re building an array of length n using numbers from 1 to k, with two rules: the first element must be 1, and the last must be x. Also, no two adjacent elements can be the same. So I tracked two cases: how many ways the array can end with x (endWithX) and how many ways it can end with something else (endWithNotX). For the base case, if x === 1, then the array starts and ends with 1, so endWithX = 1. Otherwise, it ends with something else, so endWithNotX = 1. Then I looped from position 2 to n, updating both values: if the previous ends with not-x, I can safely place x; if it ends with x or not-x, I calculate how many ways I can place a different number. I used modulo 1e9 + 7 to keep the result within limits. In the end, I returned endWithX because the last element must be x.
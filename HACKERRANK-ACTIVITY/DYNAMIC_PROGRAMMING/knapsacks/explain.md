We’re given a target sum k and an array of numbers. We can use any number from the array as many times as we want, and we need to get the maximum sum that doesn’t go over k. So I used dynamic programming: I created a dp[] array where dp[j] stores the best sum we can get for total j. For each number in arr, I looped through all totals from that number up to k, and updated the best sum using dp[j - arr[i]] + arr[i]. In the end, dp[k] holds the answer — the closest sum to k without going over.